Git和SVN，CVS一样，是一种源代码管理系统。和后两者不同的是，它不仅可以集中式管理，也可以以分布式的形式工作，即所有操作都在本地，速度快，且本地提交不会影响共享的代码仓库。Git功能很多，本文列了一些常见用法。

## 配置和创建代码仓库

设置提交时的编辑器（默认是nano）：

	$ export GIT_EDITOR=vim  

或者

	$ git config --global core.editor vim

设置文件比较工具：

	$ git config --global merge.tool vimdiff
	
	$ git config --global diff.tool vimdiff
	
	$ git config --global difftool.prompt No

忽略文件权限：

	$ git config core.filemode false


配置个人信息，即提交时显示的作者信息，如：

	$ git config user.name "jzj"
	$ git config user.email "jzj@domain"


这些git config命令其实是写到~/.gitconfig这个配置文件中，直接写这个文件效果是一样的，比如要使git命令的输出有高亮，则在.gitconfig中加

	[color]
	
	    ui = auto



创建一个新Git仓库：

	$ git init

## 查询信息(inquiry)


查看配置信息：

	$ git config --list

查看仓库的状态信息：

	$ git status

查看两个版本的差异

	$ git diff
 
由于Git中引入了index的概念，因此和svn相比，git diff可分为加--cached和不加两种：

	$ git diff  # 显示本地改动但没有stage的改动
	$ git diff --cached # 显示已经stage过的本地改动，也就是如果执行git commit会提交的改动

	$ git diff master..test # 两个branch间的差别
	$ git diff --stat  # 显示统计信息

历史信息

	$ git log
	$ git log -p # 显示patch
	$ git log --stat  # 行数统计
	$ git log --topo-order --graph # 用简单图形显示commit间的拓扑关系
	$ git log -n # 仅列出前n个
	$ git show-branch  --more=n # 前n个提交历史信息

查看更改内容

	$ git show <sha> # 查看指定commit的改动

另外，对工作目录中文件操作有git ls-files，git grep等命令。

## 提交(commit)

和SVN不同的是，Git中的Checkin分两步，即stage和commit。如：

	$ git add a.c  # stage改动，更改index（index是一个临时动态文件，描述了整个工程目录，并记录了作了哪些改动）。stage过的改动会在git diff --cached中显示出来。
	$ git commit -m "comments" # 提交改动

加-a参数可以将前面两步合二为一：

	$ git commit -a

但它仅限于tracked的文件。比如新建一个文件但没有git add过，它还是untracked状态，那加-a也没用。

## 补丁(patch)

生成补丁

	$ git format-patch -n  master # 生成最近n次commit的patch
	$ git format-patch master~4..master~2 # 生成master~4和master~2之间差异的patch
	$ git format-patch -s <sha> # 生成指定commit的patch，加签名
	应用补丁
	git am 用了git apply，用它打补丁会生成commit信息。如果出现错误
	previous rebase directory ../.git/rebase-apply still exists but mbox given
	可以用
	$ git am --abort

前面方法用于已经commit的更改，如果是用git diff生成的本地修改的patch，则可以用下面方法：
生成本地修改的patch：

	$ git diff | tee diff.patch

应用patch时用：

	$ git apply --ignore-space-change --ignore-whitespace diff.patch

或者

	$ patc -p1 < diff.patch

当然这更像Svn中的习惯，在git里反正是本地提交，提交的成本很低，所以可以先提交再生成patch。

branch之间打patch用：

	$ git cherry-pick

## 撤消(undo)

和撤消相关的有三个命令：git checkout, git revert和git reset。

如取消本地没有stage过的改动（即没有通过git add等命令记录到index中的改动）：

	$ git checkout . # index不变，工作目录改变

再如

	$ git checkout HEAD^  # 返档到前一次commit的版本
	$ git checkout <sha>  # 返档到指定commit版本

git reset 不仅作用于工作目录，而且作用于index文件。git reset有三种方式，分别为soft, hard和mixed方式。

	$ git reset --soft <sha> # 既不影响index也不影响工作目录，也就是说用git diff --cached还是可以看到撤消的改动
	$ git reset --mixed <sha> # index改变，但工作目录不变
	$ git reset --hard <sha>，# 将index和工作目录都恢复到指定版本。相当于svn revert -R *

撤消后，git log无法看到撤消的commit历史，但可以用下面命令看到：

	$ git reflog

git checkout和git reset --hard的区别在于：

	git checkout .  # 清除本地更改，但不清除index。举例来说，之前git add但没commit的作用还在。
	git reset --hard HEAD  # 清除本地更改，包括index。所以git add过的也清除了。

git revert 进行一次与指定版本相反的commit。如：

	$ git revert <sha> # commit一次和<sha>指定commit相反的改动
	$ git revert -n <sha> # 和前一命令一样，但不提交

git revert可以把中间的commit作用消除，且git revert不会改变已有的历史记录。当项目是基于已有Git仓库时这很有用。

如果只是想修改commit时的提交信息，可以用：

	$ git commit --amend

## 分支(branch)

新建

	$ git branch new_branch

或

	$ git checkout -b new_branch

查看

	$ git show-branch

提取

	$ git checkout new_branch

删除

	$ git branch -d new_branch

归并其它分支

	$ git merge branchname

杂项：
某些文件不需要让Git去track，可以在.gitignore中设置忽略这些文件。

指定特定文件用--，如：

	$ git checkout -- dir/main.c

Git有几个内置的符号索引指针：

	HEAD：永远指向当前分支的最近一次commit
	ORIG_HEAD：git reset或git merge后，原来的HEAD被存在这里
	FETCH_HEAD：git fetch后所有分支的头索引指针
	MERGE_HEAD：git merge时另一分支的头索引指针

相对索引：HEAD^ HEAD^^ HEAD~2 HEAD@{2}等

如果手头的工作做了一半，但有一个小的但紧急的bug要fix，可以用git stash。它像一个栈一样将当前的工作上下文push到栈中，当bug fix完了再pop出来。

	$ git stash "current work"
	$ git commit -a -m "trivial bug fix"
	$ git stash apply
 
gitk：图形化的git diff

当碰到regression时，可以用git bisect和git blame。前者用来查找问题从哪个版本开始出现，后者列出每行代码的修改者和时间。

## 分布式管理

复制代码仓库

	$ git clone /tmp/repo repo # 在当前目录下创建/tmp/repo的代码仓库拷贝

复制远程代码仓库（如用户名zjin，主机名zjin-machine）

	$ git clone zjin@zjin-machine:/home/zjin/repo

向远程代码仓库提交

	$ git push /tmp/repo master # 将本地master分支中的改动提交到/tmp/repo中
	从远程代码仓库同步
	$ git pull /tmp/repo master # 将/tmp/repo中的改动同步到本地的master分支中
	该命令相当于git fetch 加 git merge
